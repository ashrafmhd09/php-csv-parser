#labels Featured
 = Method:appendColumn = 

_ column appender _

Appends a column and each or all values in it can be
dinamically filled. Only when the $values argument is given.


*Code*
{{{


var_export($csv->fillColumn('age', 99));
true

var_export($csv->appendColumn('candy_ownership', array(99, 44, 65)));
true

var_export($csv->appendColumn('import_id', 111111111));
true

var_export($csv->connect());

array (
0 =>
array (
'name' => 'john',
'age' => 99,
'skill' => 'knows magic',
'candy_ownership' => 99,
'import_id' => 111111111,
),
1 =>
array (
'name' => 'tanaka',
'age' => 99,
'skill' => 'makes sushi',
'candy_ownership' => 44,
'import_id' => 111111111,
),
2 =>
array (
'name' => 'jose',
'age' => 99,
'skill' => 'dances salsa',
'candy_ownership' => 65,
'import_id' => 111111111,
),
)

}}}


  # *Argument* _string_  $column an item returned by headers()
  # *Argument* _mixed_   $values same as fillColumn()

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* headers(), fillColumn(), fillCell(), createHeaders(),
injectHeaders()

----

 = Method:appendRow = 

_ row appender _

  # *Argument* _array_  $values the values to be appended to the row

  * *Visibility*  public
  * *Returns* boolean

----

 = Method:asymmetry = 

_ asymmetric data fetcher _

finds the rows that do not match the headers length

lets assume that we add one more row to our csv file.
that has only two values. Something like



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
niki,6
}}}


Then in our php code



*Code*
{{{
$csv->uses('my_cool.csv');
var_export($csv->asymmetry());
}}}


The result



*Code*
{{{

array (
0 =>
array (
0 => 'niki',
1 => '6',
),
)

}}}


  * *Visibility*  public
  * *Returns* array filled with rows that do not match headers
  * *Also see* headers(), symmetrize(), symmetric()

----

 = Method:cell = 

_ cell fetcher _

gets the value of a specific cell by given coordinates

Note: That indexes start with zero, and headers are not
searched!

For example if we are trying to grab the cell that is in the
second row and the third column



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


we would do something like


*Code*
{{{
var_export($csv->cell(1, 2));
}}}


and get the following results


*Code*
{{{
'makes sushi'
}}}


  # *Argument* _integer_  $x the row to fetch
  # *Argument* _integer_  $y the column to fetch

  * *Visibility*  public
  * *Returns* mixed|false the value of the cell or false if the cell does
not exist
  * *Also see* headers(), coordinateable(), row(), rows(), column()

----

 = Method:column = 

_ column fetcher _

gets all the data for a specific column identified by $name

Note $name is the same as the items returned by headers()

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{
$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');
var_export($csv->column('name'));
}}}


the above example outputs something like



*Code*
{{{

array (
0 => 'john',
1 => 'tanaka',
2 => 'jose',
)

}}}


  # *Argument* _string_  $name the name of the column to fetch

  * *Visibility*  public
  * *Returns* array filled with values of a column
  * *Also see* headers(), fillColumn(), appendColumn(), cell(), rows(),
row(), columnExists()

----

 = Method:columnExists = 

_ column existance checker _

checks if a column exists, columns are identified by their
header name.

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{
$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');
$headers = $csv->headers();
}}}


now lets check if the columns exist



*Code*
{{{
var_export($csv->columnExists($headers[0]));    // true
var_export($csv->columnExists('age'));          // true
var_export($csv->columnExists('I dont exist')); // false
}}}


  # *Argument* _string_  $string an item returned by headers()

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* headers()

----

 = Method:connect = 

_ header and row relationship builder _

Attempts to create a relationship for every single cell that
was captured and its corresponding header. The sample below shows
how a connection/relationship is built.

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{

$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');

if (!$csv->symmetric()) {
die('file has headers and rows with different lengths
cannot connect');
}

var_export($csv->connect());

array (
0 =>
array (
'name' => 'john',
'age' => '13',
'skill' => 'knows magic',
),
1 =>
array (
'name' => 'tanaka',
'age' => '8',
'skill' => 'makes sushi',
),
2 =>
array (
'name' => 'jose',
'age' => '5',
'skill' => 'dances salsa',
),
)

}}}



You can pass a collection of headers in an array to build
a connection for those columns only!



*Code*
{{{

var_export($csv->connect(array('age')));

array (
0 =>
array (
'age' => '13',
),
1 =>
array (
'age' => '8',
),
2 =>
array (
'age' => '5',
),
)

}}}


  # *Argument* _array_  $columns the columns to connect, if nothing
is given all headers will be used to create a connection

  * *Visibility*  public
  * *Returns* array If the data is not symmetric an empty array
will be returned instead
  * *Also see* symmetric(), asymmetry(), symmetrize(), headers()

----

 = Method:coordinateable = 

_ checks if a coordinate is valid _

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


load the csv file



*Code*
{{{
$csv = new File_CSV_Get;
var_export($csv->uses('my_cool.csv'));   // true if file is
// loaded
}}}


find out if a coordinate is valid



*Code*
{{{
var_export($csv->coordinateable(99, 3)); // false
}}}


check again for a know valid coordinate and grab that cell



*Code*
{{{
var_export($csv->coordinateable(1, 1));  // true
var_export($csv->cell(1, 1));            // '8'
}}}


  # *Argument* _mixed_  $x the row to fetch
  # *Argument* _mixed_  $y the column to fetch

  * *Visibility*  public
  * *Returns* void

----

 = Method:countHeaders = 

_ header counter _

  * *Visibility*  public
  * *Returns* integer gets the length of headers

----

 = Method:countRows = 

_ row counter _

This function will exclude the headers

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{
$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');
var_export($csv->countRows()); // returns 3
}}}


  * *Visibility*  public
  * *Returns* integer

----

 = Method:createHeaders = 

_ header creator _

uses prefix and creates a header for each column suffixed by a
numeric value

by default the first row is interpreted as headers but if we
have a csv file with data only and no headers it becomes really
annoying to work with the current loaded data.

this function will create a set dinamically generated headers
and make the current headers accessable with the row handling
functions

Note: that the csv file contains only data but no headers
sample of a csv file "my_cool.csv"



*Code*
{{{
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


checks if the csv file was loaded



*Code*
{{{
$csv = new File_CSV_Get;
if (!$csv->uses('my_cool.csv')) {
die('can not load csv file');
}
}}}


dump current headers



*Code*
{{{
var_export($csv->headers());
}}}


standard output



*Code*
{{{
array (
0 => 'john',
1 => '13',
2 => 'knows magic',
)
}}}


generate headers named 'column' suffixed by a number and interpret
the previous headers as rows.



*Code*
{{{
$csv->createHeaders('column')
}}}


dump current headers



*Code*
{{{
var_export($csv->headers());
}}}


standard output



*Code*
{{{
array (
0 => 'column_1',
1 => 'column_2',
2 => 'column_3',
)
}}}


build a relationship and dump it



*Code*
{{{
var_export($csv->connect());
}}}


standard output



*Code*
{{{

array (
0 =>
array (
'column_1' => 'john',
'column_2' => '13',
'column_3' => 'knows magic',
),
1 =>
array (
'column_1' => 'tanaka',
'column_2' => '8',
'column_3' => 'makes sushi',
),
2 =>
array (
'column_1' => 'jose',
'column_2' => '5',
'column_3' => 'dances salsa',
),
)
}}}


  # *Argument* _string_  $prefix check your database engine for valid
column naming conventions.

  * *Visibility*  public
  * *Returns* boolean fails if data is not symmetric
  * *Also see* symmetric(), asymmetry()

----

 = Method:fillCell = 

_ cell value filler _

replaces the value of a specific cell

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{

$csv = new File_CSV_Get;

// load the csv file
$csv->uses('my_cool.csv');

// find out if the given coordinate is valid
if($csv->coordinateable(1, 1)) {

// if so grab that cell and dump it
var_export($csv->cell(1, 1));       // '8'

// replace the value of that cell
$csv->fillCell(1, 1, 'new value');  // true

// output the new value of the cell
var_export($csv->cell(1, 1));       // 'new value'

}
}}}


now lets try to grab the whole row



*Code*
{{{
// show the whole row
var_export($csv->row(1));
}}}


standard output



*Code*
{{{
array (
0 => 'tanaka',
1 => 'new value',
2 => 'makes sushi',
)
}}}


  # *Argument* _integer_  $x     the row to fetch
  # *Argument* _integer_  $y     the column to fetch
  # *Argument* _mixed_    $value the value to fill the cell with

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* coordinateable(), row(), rows(), column()

----

 = Method:fillColumn = 

_ collumn data injector _

fills alll the data in the given column with $values

sample of a csv file "my_cool.csv"



*Code*
{{{
name,age,skill
john,13,knows magic
tanaka,8,makes sushi
jose,5,dances salsa
}}}


php implementation



*Code*
{{{
$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');

// if the csv file loads
if ($csv->uses('my_cool.csv')) {

// grab all data within the age column
var_export($csv->column('age'));

// rename all values in it with the number 99
var_export($csv->fillColumn('age', 99));

// grab all data within the age column
var_export($csv->column('age'));

// rename each value in a column independently
$data = array(1, 2, 3);
$csv->fillColumn('age', $data);

var_export($csv->column('age'));
}
}}}


standard output



*Code*
{{{
array (
0 => '13',
1 => '8',
2 => '5',
)
}}}




*Code*
{{{
true
}}}




*Code*
{{{
array (
0 => 99,
1 => 99,
2 => 99,
)
}}}




*Code*
{{{
array (
0 => 1,
1 => 2,
2 => 3,
)
}}}


  # *Argument* _mixed_  $column the column identified by a string
  # *Argument* _mixed_  $values ither one of the following
  #  (Number) will fill the whole column with the value of number
  #  (String) will fill the whole column with the value of string
  #  (Array) will fill the while column with the values of array
the array gets ignored if it does not match the length of rows

  * *Visibility*  public
  * *Returns* void

----

 = Method:fillRow = 

_ fillRow _

  # *Argument* _integer_  $row    the row to fill identified by its key
  # *Argument* _mixed_    $values the value to use, if a string or number
is given the whole row will be replaced with this value.
if an array is given instead the values will be used to fill
the row. Only when the currently loaded dataset is symmetric

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* symmetric(), asymmetric(), symmetrize(), fillColumn(),
fillCell()

----

 = Method:headers = 

_ header fetcher _

gets csv headers into an array



*Code*
{{{

var_export($csv->headers());

array (
0 => 'name',
1 => 'age',
2 => 'skill',
)

}}}


  * *Visibility*  public
  * *Returns* array

----

 = Method:injectHeaders = 

_ header injector _

uses a $list array filled with strings to fill headers to be
used by this object.

Note: that given $list must match the length of all rows and
this must be symmetric.

  # *Argument* _array_  $list a collection of names to use as headers,
check your database engine for column-name conventions.

  * *Visibility*  public

  * *Returns* boolean fails if data is not symmetric
  * *Also see* symmetric(), asymmetry()

----

 = Method:rawArray = 

_ raw data as array _

  * *Visibility*  public
  * *Returns* array

----

 = Method:removeColumn = 

_ column remover _

completly removes a whole column identified by header
Note: that this function will only work if data is symmetric.

  # *Argument* _string_  $name same as the ones returned by headers();

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* headers(), createHeaders(), injectHeaders(), symmetric(),
asymmetric()

----

 = Method:removeRow = 

_ row remover _

removes one row from the current data set.

  # *Argument* _mixed_  $number the key that identifies that row

  * *Visibility*  public
  * *Returns* boolean

----

 = Method:row = 

_ row fetcher _

Note: first row is zero

  # *Argument* _integer_  $number the row number to fetch

  * *Visibility*  public
  * *Returns* array the row identified by number, if $number does
not exist an empty array is returned instead


*Code*
{{{
$array = $csv->row(3); # array('val1', 'val2', 'val3')
}}}


----

 = Method:rowExists = 

_ row existance checker _

  # *Argument* _mixed_  $number a numeric value that identifies the row
you are trying to fetch.

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* row(), rows(), appendRow(), fillRow()

----

 = Method:rows = 

_ multiple row fetcher _

extracts csv rows excluding the headers

  # *Argument* _array_  $range a list of rows to retrive

  * *Visibility*  public
  * *Returns* array

----

 = Method:settings = 

_ settings alterator _

lets you define different settings for scanning

  # *Argument* _mixed_  $array containing settings to use

  * *Visibility*  public
  * *Returns* boolean true if changes where applyed successfully
  * *Also see* $settings

----

 = Method:symmetric = 

_ data length/symmetry checker _

tells if the headers and all of the contents length match.

  * *Visibility*  public
  * *Returns* boolean

----

 = Method:symmetrize = 

_ all rows length equalizer _

makes the length of all rows and headers the same. If no $value is given
all unexistent cells will be filled with empty spaces

  # *Argument* _mixed_  $value the value to fill the unexistent cells

  * *Visibility*  public
  * *Returns* void

----

 = Method:uses = 

_ csv file loader _

indicates the object which file is to be loaded



*Code*
{{{

require_once 'File/CSV/Get.php';

$csv = new File_CSV_Get;
$csv->uses('my_cool.csv');
var_export($csv->connect());

array (
0 =>
array (
'name' => 'john',
'age' => '13',
'skill' => 'knows magic',
),
1 =>
array (
'name' => 'tanaka',
'age' => '8',
'skill' => 'makes sushi',
),
2 =>
array (
'name' => 'jose',
'age' => '5',
'skill' => 'dances salsa',
),
)

}}}


  # *Argument* _string_  $filename the csv filename to load

  * *Visibility*  public
  * *Returns* boolean true if file was loaded successfully
  * *Also see* symmetric(), asymmetry(), symmetrize()

----

 = Method:walkColumn = 

_ column walker _

goes through the whole column and executes a callback for each 
one of the cells in it.

Note: callback functions get the value of the cell as an 
argument, and whatever that callback returns will be used to 
replace the current value of that cell.

  # *Argument* _string_  $name     the header name used to identify the column
  # *Argument* _string_  $callback the callback function to be called per 
each cell value

  * *Visibility*  public
  * *Returns* boolean
  * *Also see* headers(), fillColumn(), appendColumn()

----

 = Method:walkGrid = 

_ grid walker _

travels through the whole dataset executing a callback per each 
cell

Note: callback functions get the value of the cell as an 
argument, and whatever that callback returns will be used to 
replace the current value of that cell.

  # *Argument* _string_  $callback the callback function to be called per
each cell in the dataset.

  * *Visibility*  public
  * *Returns* void
  * *Also see* walkColumn(), walkRow(), fillColumn(), fillRow(), fillCell()

----

 = Method:walkRow = 

_ row walker _

goes through one full row of data and executes a callback
function per each cell in that row.

Note: callback functions get the value of the cell as an 
argument, and whatever that callback returns will be used to 
replace the current value of that cell.

  # *Argument* _string_ |integer $row      anything that is numeric is a valid row
identificator. As long as it is within the range of the currently
loaded dataset

  # *Argument* _string_          $callback the callback function to be executed
per each cell in a row

  * *Visibility*  public
  * *Returns* boolean
  #  false if callback does not exist
  #  false if row does not exits

----